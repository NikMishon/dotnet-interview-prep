# Frontend: Razor & Blazor

В экосистеме .NET существуют нативные инструменты для создания пользовательских интерфейсов, которые позволяют C#-разработчикам писать frontend-логику без использования JavaScript.

## 1. Razor

- **Что это?** Razor — это **синтаксис разметки** для встраивания кода на основе .NET в веб-страницы. Это не язык и не фреймворк, а именно синтаксис.
- **Как выглядит?** Использует символ `@` для перехода от HTML-разметки к C#-коду.
- **Где используется?**
  - **ASP.NET Core MVC**: Razor используется для создания Представлений (`View`). Контроллер подготавливает модель, передает ее в `.cshtml` файл, и Razor генерирует итоговый HTML на сервере.
  - **Razor Pages**: Более простая альтернатива MVC, где страница (`.cshtml`) и ее код (`.cshtml.cs`) объединены. Подходит для простых, странично-ориентированных приложений.
  - **Blazor**: Используется как шаблонизатор для компонентов.

```csharp
// Пример синтаксиса Razor (.cshtml)

@page "/products"
@inject IProductService ProductService

<h1>Наши продукты</h1>

@if (products == null)
{
    <p><em>Загрузка...</em></p>
}
else
{
    <ul>
        @foreach (var product in products)
        {
            <li>@product.Name (@product.Price.ToString("c"))</li>
        }
    </ul>
}

@code {
    private List<Product>? products;

    protected override async Task OnInitializedAsync()
    {
        products = await ProductService.GetAllAsync();
    }
}
```

## 2. Blazor

- **Что это?** Blazor — это **фреймворк** для создания интерактивных веб-интерфейсов с использованием C# вместо JavaScript. Blazor позволяет создавать **компонентно-ориентированный** UI.

### Модели хостинга (Hosting Models)

Это ключевое понятие в Blazor. Модель хостинга определяет, **где** выполняется ваш C#-код.

#### 1. Blazor Server
- **Где выполняется код?** На **сервере**.
- **Как работает?**
  1.  Клиент (браузер) загружает небольшую JavaScript-библиотеку.
  2.  Эта библиотека устанавливает постоянное **WebSocket-соединение** с сервером через **SignalR**.
  3.  Когда пользователь взаимодействует с интерфейсом (нажимает кнопку), информация об этом событии отправляется на сервер по WebSocket.
  4.  Ваш C#-код на сервере обрабатывает событие.
  5.  Blazor на сервере вычисляет, какие части HTML-разметки (DOM) изменились.
  6.  Эта **разница** (diff) отправляется обратно клиенту по WebSocket.
  7.  JavaScript на клиенте применяет эту разницу к DOM.
- **Плюсы**:
  - Тонкий клиент, быстрая первоначальная загрузка.
  - Весь код выполняется на сервере, он в безопасности.
  - Полная совместимость с .NET API.
- **Минусы**:
  - Требует постоянного активного соединения с сервером.
  - Есть задержка (latency) при каждом взаимодействии.
  - Не работает в оффлайн-режиме.
  - Проблемы с масштабируемостью (каждый клиент держит соединение на сервере).

#### 2. Blazor WebAssembly (Wasm)
- **Где выполняется код?** В **браузере** клиента.
- **Как работает?**
  1.  При первой загрузке в браузер скачивается среда выполнения .NET, скомпилированная в **WebAssembly**, а также сборки вашего приложения (`.dll`).
  2.  Далее C#-код выполняется непосредственно в браузере в той же "песочнице", что и JavaScript.
  3.  Взаимодействие с DOM происходит напрямую, без задержек.
  4.  Для получения данных с сервера используются обычные HTTP-вызовы к Web API.
- **Плюсы**:
  - Полноценное клиентское приложение.
  - Нет задержек на взаимодействие с UI.
  - Может работать в оффлайн-режиме (как PWA).
  - Снижает нагрузку на сервер (сервер нужен только как API).
- **Минусы**:
  - Большая первоначальная загрузка (нужно скачать .NET runtime).
  - Выполнение может быть медленнее, чем на сервере.
  - Ограниченная совместимость с .NET API (зависит от того, что поддерживается в браузере).

#### 3. Blazor Auto (Новое в .NET 8)
- **Как работает?** Комбинирует лучшее из двух миров.
  - При первой загрузке используется модель **Blazor Server** для максимально быстрого отображения интерактивного UI.
  - В фоне начинается загрузка **WebAssembly**.
  - Когда Wasm-ресурсы загружены, приложение автоматически переключается на модель **Blazor WebAssembly** для последующих взаимодействий.
- **Цель**: Быстрый старт и полноценная клиентская работа после него.

### Жизненный цикл компонента
- `OnInitialized()` / `OnInitializedAsync()`: Вызывается один раз при создании компонента. Идеально для загрузки данных.
- `OnParametersSet()` / `OnParametersSetAsync()`: Вызывается при инициализации и каждый раз, когда компонент получает новые параметры от родителя.
- `ShouldRender()`: Позволяет управлять тем, нужно ли перерисовывать компонент.
- `OnAfterRender()` / `OnAfterRenderAsync()`: Вызывается после того, как компонент был отрисован. Здесь можно безопасно работать с JavaScript-библиотеками. 