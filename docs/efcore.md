# Entity Framework Core: Ключевые аспекты

EF Core — это современный, кроссплатформенный ORM (Object-Relational Mapper) для .NET. Он позволяет разработчикам работать с базой данных, используя .NET-объекты, и избавляет от необходимости писать большую часть кода для доступа к данным.

## 1. DbContext и DbSet
- **`DbContext`**: Представляет сессию с базой данных. Он отвечает за:
  - **Конфигурацию соединения**: Управление строкой подключения.
  - **Маппинг моделей**: Настройка того, как классы .NET соответствуют таблицам в БД (с помощью Fluent API в методе `OnModelCreating` или с помощью атрибутов).
  - **Отслеживание изменений (Change Tracking)**: Хранение информации о том, какие сущности были добавлены, изменены или удалены.
  - **Unit of Work**: Группировка нескольких операций в одну транзакцию.
- **`DbSet<T>`**: Представляет коллекцию сущностей определенного типа (таблицу в БД). Через `DbSet` выполняются все CRUD-операции (Create, Read, Update, Delete).

```csharp
public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }

    public DbSet<Product> Products { get; set; }
    public DbSet<Order> Orders { get; set; }
}
```

## 2. LINQ to Entities
- EF Core позволяет использовать LINQ для написания запросов к базе данных.
- **`IQueryable<T>`**: Когда вы пишете LINQ-запрос к `DbSet`, вы работаете с `IQueryable`. Это означает, что запрос не выполняется немедленно. Вместо этого EF Core строит **дерево выражений (Expression Tree)**.
- **Отложенное выполнение (Deferred Execution)**: Сам SQL-запрос генерируется и отправляется в базу данных только тогда, когда вы начинаете итерировать по результатам (например, вызывая `ToList()`, `FirstOrDefault()`, `foreach`).
- Это позволяет EF Core оптимизировать SQL, например, выполнив `WHERE`, `ORDER BY`, `JOIN` на стороне сервера базы данных, а не в памяти приложения.

```csharp
// Этот код не выполняет запрос к БД
var query = context.Products
                   .Where(p => p.IsAvailable)
                   .OrderBy(p => p.Name);

// Запрос выполняется здесь. EF Core сгенерирует SQL с WHERE и ORDER BY.
var products = query.ToList(); 
```

## 3. Change Tracker (Отслеживание изменений)
- **Как работает**: Когда вы загружаете сущность из БД с помощью `DbContext`, он создает "снимок" (snapshot) ее состояния. Когда вы вызываете `SaveChanges()`, `DbContext` сравнивает текущее состояние сущности со снимком, чтобы определить, какие поля изменились, и генерирует соответствующие SQL-запросы (`INSERT`, `UPDATE`, `DELETE`).
- **Состояния сущностей**:
  - `Added`: Сущность будет вставлена в БД.
  - `Modified`: Сущность будет обновлена.
  - `Deleted`: Сущность будет удалена.
  - `Unchanged`: Сущность не изменилась.
  - `Detached`: Сущность не отслеживается `DbContext`.
- **Производительность**: Для операций, где нужно только читать данные и не нужно их изменять, отслеживание можно отключать с помощью `.AsNoTracking()`. Это значительно ускоряет запросы, так как EF не тратит время на создание снимков.
  ```csharp
  var products = await _context.Products.AsNoTracking().ToListAsync();
  ```

## 4. Стратегии загрузки связанных данных
- **Eager Loading (Жадная загрузка)**: Связанные данные загружаются **в одном запросе** с основной сущностью с помощью `Include()` и `ThenInclude()`.
  ```csharp
  // Загрузить автора и все его книги в одном SQL-запросе (с JOIN)
  var author = await _context.Authors.Include(a => a.Books).FirstAsync();
  ```
- **Explicit Loading (Явная загрузка)**: Связанные данные загружаются **отдельным запросом** позже, по требованию.
  ```csharp
  var author = await _context.Authors.FirstAsync();
  // ... позже ...
  // Загрузить книги для этого автора отдельным запросом
  await _context.Entry(author).Collection(a => a.Books).LoadAsync();
  ```
- **Lazy Loading (Ленивая загрузка)**: Связанные данные загружаются **автоматически при первом обращении** к навигационному свойству.
  - **Требования**: Все навигационные свойства должны быть `virtual`. Требуется установка пакета `Microsoft.EntityFrameworkCore.Proxies`.
  - **Опасность**: Может приводить к проблеме "N+1", когда один запрос на получение списка сущностей порождает N дополнительных запросов на загрузку связанных данных для каждой из них. **Использовать с большой осторожностью!**

## 5. Миграции (Migrations)
- **Что это**: Инструмент для последовательного развития схемы базы данных и ее синхронизации с доменной моделью.
- **Процесс**:
  1. Вы изменяете свои классы-сущности (например, добавляете новое свойство).
  2. Выполняете команду `dotnet ef migrations add MyNewMigration`. EF Core сравнивает текущую модель с последним снимком модели (снапшотом миграции) и генерирует C#-код, описывающий изменения в схеме (например, `ALTER TABLE ... ADD COLUMN ...`).
  3. Выполняете команду `dotnet ef database update`. EF Core применяет новую миграцию к базе данных.

## 6. Оптимистическая блокировка (Optimistic Concurrency)
- **Проблема**: Что делать, если два пользователя одновременно редактируют одну и ту же запись? Последний сохранивший "затрет" изменения первого.
- **Решение**: EF Core может проверять, не изменились ли данные в базе данных с момента их чтения.
- **Как работает**:
  1. Добавьте в сущность свойство с атрибутом `[ConcurrencyCheck]` или `[Timestamp]` (для `rowversion` в SQL Server).
     ```csharp
     public class Product 
     {
         public int Id { get; set; }
         [ConcurrencyCheck]
         public string Name { get; set; }
     }
     ```
  2. Когда вы вызываете `SaveChanges()`, EF включает в `WHERE`-условие `UPDATE`-запроса не только `Id`, но и исходное значение поля, помеченного как `ConcurrencyCheck`.
  3. Если за это время другой пользователь изменил данные, `WHERE`-условие не найдет ни одной строки для обновления (`UPDATE` вернет 0 измененных строк).
  4. EF Core обнаружит это и выбросит исключение `DbUpdateConcurrencyException`, которое вы можете обработать (например, сообщить пользователю, что данные устарели).

## 7. Глобальные фильтры запросов (Global Query Filters)
- **Что это**: Позволяют определить LINQ-предикат, который будет **автоматически** применяться ко всем запросам для определенной сущности.
- **Пример**: "Мягкое удаление" (Soft Deletes). Вместо физического удаления записей вы просто помечаете их как удаленные.
  ```csharp
  // В OnModelCreating в DbContext
  modelBuilder.Entity<Product>().HasQueryFilter(p => !p.IsDeleted);

  // Теперь любой запрос к _context.Products не будет возвращать удаленные товары
  ```

## 8. Производительность (Performance)
- **Проблема N+1**: Распространенная ошибка, когда вы сначала загружаете коллекцию родительских сущностей, а затем в цикле для каждой из них делаете отдельный запрос к БД для загрузки дочерних сущностей.
  - **Решение**: Используйте **"жадную" загрузку (Eager Loading)** с помощью `Include()` и `ThenInclude()`, чтобы загрузить все необходимые данные одним запросом с `JOIN`.

```csharp
// ПЛОХО: 1 запрос на заказы + N запросов на продукты (проблема N+1)
var orders = context.Orders.ToList();
foreach (var order in orders)
{
    // Отдельный запрос на каждый заказ
    var items = context.OrderItems.Where(i => i.OrderId == order.Id).ToList();
}

// ХОРОШО: 1 запрос, который загружает заказы вместе с их позициями
var ordersWithItems = context.Orders
                             .Include(o => o.Items) // Загрузить связанные OrderItems
                             .ThenInclude(i => i.Product) // А для них загрузить Продукты
                             .ToList();
```
- **Другие техники**:
  - **Выполнение "сырых" SQL-запросов** (`FromSqlRaw`) и **Dapper** для особо критичных к производительности запросов. 