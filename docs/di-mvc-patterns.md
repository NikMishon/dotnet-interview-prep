# DI, IoC и паттерны UI (MVC, MVP, MVVM)

## 1. IoC (Inversion of Control) - Инверсия управления
- **Принцип**: Фундаментальный принцип проектирования, который делегирует управление жизненным циклом объектов и их зависимостями внешнему фреймворку или контейнеру. Вместо того чтобы компонент сам создавал свои зависимости (`new MyService()`), он получает их извне.
- **Цель**: Достижение слабой связности (loose coupling) между компонентами системы.

## 2. DI (Dependency Injection) - Внедрение зависимостей
- **Что это**: Конкретная реализация принципа IoC. Это паттерн, при котором зависимости объекта (сервисы, репозитории и т.д.) предоставляются ему контейнером, а не создаются им самим.
- **Типы DI**:
  - **Constructor Injection (Внедрение через конструктор)**: Зависимости передаются как параметры конструктора. **Это предпочтительный способ**, так как он делает зависимости явными и гарантирует, что объект будет в корректном состоянии сразу после создания.
    ```csharp
    public class MyController
    {
        private readonly IUserService _userService;
        // Зависимость IUserService внедряется через конструктор
        public MyController(IUserService userService)
        {
            _userService = userService;
        }
    }
    ```
  - **Property Injection (Внедрение через свойство)**: Зависимости устанавливаются через публичные свойства после создания объекта. Используется для необязательных зависимостей.
  - **Method Injection (Внедрение через метод)**: Зависимость передается как параметр метода, который её использует. Используется, когда зависимость нужна только для одного конкретного метода.

- **DI-контейнеры**: Инструменты, которые автоматизируют процесс DI. Они отвечают за создание объектов и разрешение их зависимостей.
  - **Пример**: `Microsoft.Extensions.DependencyInjection` (встроенный в ASP.NET Core).
  - **Регистрация сервисов**:
    ```csharp
    var builder = WebApplication.CreateBuilder(args);
    // Регистрация IUserService с реализацией UserService
    builder.Services.AddScoped<IUserService, UserService>();
    ```
- **Service Lifetimes (Времена жизни сервисов)**:
  - **Transient**: Новый экземпляр сервиса создается **каждый раз**, когда он запрашивается из контейнера.
    `builder.Services.AddTransient<IMyService, MyService>();`
  - **Scoped**: Новый экземпляр создается **один раз за запрос** (например, за один HTTP-запрос в ASP.NET Core). Все компоненты в рамках одного запроса получают один и тот же экземпляр.
    `builder.Services.AddScoped<IMyService, MyService>();`
  - **Singleton**: Создается **один-единственный экземпляр** за все время жизни приложения. Все запросы к контейнеру возвращают этот один экземпляр.
    `builder.Services.AddSingleton<IMyService, MyService>();`

## 3. Паттерны проектирования UI
Эти паттерны помогают разделить логику представления (UI), бизнес-логику и данные.

- **MVC (Model-View-Controller)**
  - **Model**: Модель. Представляет данные и бизнес-логику. Ничего не знает о View и Controller.
  - **View**: Представление. Отображает данные из модели и передает действия пользователя в контроллер. В веб-разработке (ASP.NET Core MVC) View часто является "глупым" шаблоном (например, Razor-файл).
  - **Controller**: Контроллер. Принимает ввод от пользователя (через View), взаимодействует с Model и выбирает View для отображения. Является точкой входа и "оркестратором".
  - **Взаимодействие**: `Пользователь -> Controller -> Model -> View -> Пользователь`. Контроллер напрямую обновляет View.

- **MVP (Model-View-Presenter)**
  - **Model**: Модель (данные и бизнес-логика).
  - **View**: Представление. Становится еще более "глупым" и пассивным. Содержит только UI-элементы и делегирует *все* события (нажатия кнопок, ввод текста) Presenter'у через интерфейс (`IUserView`).
  - **Presenter**: Презентер. "Среднее звено". Получает данные от пользователя из View, обрабатывает их, взаимодействует с Model и затем напрямую обновляет View через его интерфейс. View и Presenter тесно связаны (1 к 1).
  - **Взаимодействие**: `Пользователь <-> View <-> Presenter <-> Model`. Отличие от MVC в том, что Presenter, а не Controller, напрямую работает с View. Упрощает тестирование логики представления.

- **MVVM (Model-View-ViewModel)**
  - **Model**: Модель (данные и бизнес-логика).
  - **View**: Представление. Активно, но не содержит логики. Двусторонне связано с ViewModel через привязку данных (Data Binding). View "знает" о ViewModel.
  - **ViewModel**: Модель представления. Содержит логику представления и состояние UI. Предоставляет данные из Model в формате, удобном для View (через свойства), и команды (Commands) для обработки действий пользователя. **Ничего не знает о View**.
  - **Взаимодействие**: `Пользователь <-> View <-> ViewModel <-> Model`. Связь между View и ViewModel осуществляется через механизм привязки данных. Это основной паттерн для таких фреймворков, как WPF, Avalonia, MAUI и Blazor.

| Паттерн | Связь View-Логика | Зависимости | Основное применение |
|---|---|---|---|
| **MVC** | Controller -> View | View зависит от Model | ASP.NET Core |
| **MVP** | Presenter <-> View | View и Presenter зависят друг от друга | WinForms, ранние UI-фреймворки |
| **MVVM** | View <-> ViewModel (Data Binding) | View зависит от ViewModel, ViewModel не зависит от View | WPF, MAUI, Blazor, Avalonia | 