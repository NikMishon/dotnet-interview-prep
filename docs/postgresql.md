# PostgreSQL

Этот документ содержит информацию по PostgreSQL, включая основы SQL, индексацию, транзакции и уровни изоляции.

## Основы SQL

- **SELECT**: Извлечение данных из таблицы.
  ```sql
  SELECT column1, column2 FROM table_name WHERE condition;
  ```
- **INSERT**: Добавление новых записей в таблицу.
  ```sql
  INSERT INTO table_name (column1, column2) VALUES (value1, value2);
  ```
- **UPDATE**: Модификация существующих записей.
  ```sql
  UPDATE table_name SET column1 = value1 WHERE condition;
  ```
- **DELETE**: Удаление записей.
  ```sql
  DELETE FROM table_name WHERE condition;
  ```
- **JOIN**: Объединение таблиц.
  - `INNER JOIN`: Возвращает записи с совпадающими значениями в обеих таблицах.
  - `LEFT JOIN`: Возвращает все записи из левой таблицы и совпадающие из правой.
  - `RIGHT JOIN`: Возвращает все записи из правой таблицы и совпадающие из левой.
  - `FULL OUTER JOIN`: Возвращает все записи, когда есть совпадение в одной из таблиц.
- **GROUP BY**: Группирует строки с одинаковыми значениями в указанных столбцах в итоговые строки. Часто используется с агрегатными функциями (`COUNT`, `SUM`, `AVG` и т.д.).
  ```sql
  SELECT department, COUNT(id) FROM employees GROUP BY department;
  ```
- **HAVING**: Фильтрует результаты, возвращаемые `GROUP BY`. Ключевое отличие от `WHERE` в том, что `WHERE` фильтрует строки **до** группировки, а `HAVING` — отфильтровывает группы **после** нее, что позволяет применять агрегатные функции в условии.
  ```sql
  -- Выбрать отделы, суммарная зарплата в которых превышает 50000
  SELECT department, SUM(salary)
  FROM employees
  GROUP BY department
  HAVING SUM(salary) > 50000;
  ```

## Оконные функции

Оконные функции выполняют вычисления на наборе строк (на "окне"), которые определенным образом связаны с текущей строкой. В отличие от агрегатных функций (`SUM`, `COUNT`), они не "схлопывают" строки в одну, а возвращают результат для каждой строки.

- **Основной синтаксис**: `ФУНКЦИЯ() OVER (PARTITION BY ... ORDER BY ...)`
- `PARTITION BY столбец`: Определяет "окно" или группу строк, для которых выполняется функция. Работает аналогично `GROUP BY`, но не сворачивает результат. Если пропущено, окном является весь набор строк.
- `ORDER BY столбец`: Определяет порядок строк внутри окна, что важно для функций, зависящих от порядка (например, `ROW_NUMBER`, `LAG`, `LEAD`).

### Примеры популярных оконных функций

- **`ROW_NUMBER()`**: Нумерует строки в окне в соответствии с `ORDER BY`.
  ```sql
  -- Нумерация сотрудников в каждом отделе по убыванию зарплаты
  SELECT name, department, salary,
         ROW_NUMBER() OVER(PARTITION BY department ORDER BY salary DESC) as rn
  FROM employees;
  ```

- **`RANK()` и `DENSE_RANK()`**: Присваивают ранг строке. `RANK` пропускает места после "ничьей" (например, 1, 2, 2, 4), а `DENSE_RANK` — нет (1, 2, 2, 3).
  ```sql
  -- Ранжирование сотрудников по зарплате во всей компании
  SELECT name, salary,
         RANK() OVER(ORDER BY salary DESC) as rank
  FROM employees;
  ```

- **`LAG(столбец, смещение, значение_по_умолчанию)` и `LEAD(...)`**: Позволяют получить доступ к данным из предыдущей (`LAG`) или следующей (`LEAD`) строки в окне.
  ```sql
  -- Показать зарплату предыдущего по рангу сотрудника
  SELECT name, salary,
         LAG(salary, 1, 0) OVER(ORDER BY salary DESC) as previous_salary
  FROM employees;
  ```

- **Агрегатные функции в роли оконных**: `SUM()`, `AVG()`, `COUNT()` могут работать с `OVER`.
  ```sql
  -- Показать среднюю зарплату по отделу для каждого сотрудника
  SELECT name, department, salary,
         AVG(salary) OVER(PARTITION BY department) as avg_department_salary
  FROM employees;
  
  -- Показать нарастающий итог (running total) зарплат
  SELECT name, salary,
         SUM(salary) OVER(ORDER BY id) as running_total_salary
  FROM employees;
  ```

## Индексы

Индексы используются для ускорения выполнения запросов. Без индекса СУБД должна сканировать всю таблицу.

- **B-Tree**: Наиболее распространенный тип индекса. Используется по умолчанию. Подходит для операций сравнения (`<`, `<=`, `=`, `>=`, `>`).
- **Hash**: Используется только для точного равенства (`=`).
- **GiST (Generalized Search Tree)**: Позволяет создавать произвольные древовидные структуры. Используется для полнотекстового поиска, геометрических данных.
- **GIN (Generalized Inverted Index)**: Используется для индексации данных, состоящих из множества значений, таких как массивы или полнотекстовый поиск.

Создание индекса:
```sql
CREATE INDEX index_name ON table_name (column_name);
```

## Транзакции и ACID

Транзакция — это последовательность операций, которая выполняется как единое целое. Либо все операции выполняются успешно, либо ни одна из них не оказывает влияния на состояние базы данных.

**ACID** — это акроним, описывающий свойства, гарантирующие надежность транзакций:

- **Atomicity (Атомарность)**: Транзакция выполняется полностью или не выполняется вовсе. Не может быть частичного выполнения.
- **Consistency (Согласованность)**: Транзакция переводит базу данных из одного согласованного состояния в другое. Все ограничения целостности (constraints, triggers) должны быть удовлетворены.
- **Isolation (Изолированность)**: Параллельные транзакции не должны оказывать влияния друг на друга. Результат параллельного выполнения должен быть таким же, как при последовательном.
- **Durability (Долговечность)**: Если транзакция успешно завершена, ее результаты должны быть сохранены и не могут быть потеряны в случае сбоя системы (например, отключения питания).

## Уровни изоляции транзакций

Уровни изоляции определяют, какие из аномалий параллельного доступа могут возникать.

### Аномалии параллельного доступа

1. **Грязное чтение (Dirty Read)**: Транзакция читает данные, которые были изменены другой транзакцией, но еще не зафиксированы. Если вторая транзакция откатится, первая будет работать с несуществующими данными.

   Пример:
   ```sql
   -- Транзакция 1
   BEGIN;
   UPDATE accounts SET balance = balance - 100 WHERE id = 1;
   -- balance = 900 (но еще не зафиксировано)
   
   -- Транзакция 2 (в другом соединении)
   BEGIN;
   SELECT balance FROM accounts WHERE id = 1; -- Читает 900 (грязное чтение)
   
   -- Транзакция 1
   ROLLBACK; -- Откат изменений
   
   -- Транзакция 2 работает с неверными данными
   ```

2. **Неповторяющееся чтение (Non-Repeatable Read)**: В рамках одной транзакции при повторном чтении одних и тех же данных получаются разные значения, потому что другая транзакция изменила и зафиксировала эти данные между чтениями.

   Пример:
   ```sql
   -- Транзакция 1
   BEGIN;
   SELECT balance FROM accounts WHERE id = 1; -- balance = 1000
   
   -- Транзакция 2
   BEGIN;
   UPDATE accounts SET balance = 1500 WHERE id = 1;
   COMMIT;
   
   -- Транзакция 1
   SELECT balance FROM accounts WHERE id = 1; -- balance = 1500 (изменилось!)
   ```

3. **Фантомное чтение (Phantom Read)**: При повторном выполнении запроса с условием WHERE появляются новые строки, которые были добавлены другой транзакцией между чтениями.

   Пример:
   ```sql
   -- Транзакция 1
   BEGIN;
   SELECT COUNT(*) FROM accounts WHERE balance > 1000; -- Результат: 5
   
   -- Транзакция 2
   BEGIN;
   INSERT INTO accounts (id, balance) VALUES (100, 2000);
   COMMIT;
   
   -- Транзакция 1
   SELECT COUNT(*) FROM accounts WHERE balance > 1000; -- Результат: 6 (появился фантом!)
   ```

4. **Аномалия сериализации (Serialization Anomaly)**: Результат параллельного выполнения транзакций отличается от любого возможного последовательного выполнения.

### Уровни изоляции

1. **Read Uncommitted**: Самый низкий уровень. Разрешает "грязное чтение" (dirty read) — чтение незафиксированных данных другой транзакции.
2. **Read Committed**: Уровень по умолчанию в PostgreSQL. Запрещает грязное чтение. Транзакция видит только те данные, которые были зафиксированы до ее начала. Возможны "неповторяющееся чтение" (non-repeatable read) и "фантомное чтение" (phantom read).
3. **Repeatable Read**: Гарантирует, что при повторном чтении в рамках одной транзакции данные будут теми же. Защищает от неповторяющегося чтения, но фантомные чтения все еще возможны.
4. **Serializable**: Самый строгий уровень. Гарантирует полную изоляцию транзакций друг от друга, как если бы они выполнялись последовательно. Предотвращает все аномалии, включая фантомные чтения.

Установка уровня изоляции:
```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
-- ваши запросы
COMMIT;
``` 