# Контрактное программирование в .NET

Контрактное программирование (Design by Contract, DbC) — это подход к разработке ПО, при котором компоненты системы взаимодействуют друг с другом на основе формальных "контрактов". Эти контракты определяют предусловия, постусловия и инварианты.

## 1. Основные концепции
- **Предусловия (Preconditions)**: Условия, которые должны быть истинны **перед** вызовом метода. Ответственность за их выполнение лежит на **клиенте** (вызывающем коде).
  - *Пример*: Метод принимает не-null объект, число должно быть положительным.
- **Постусловия (Postconditions)**: Условия, которые должны быть истинны **после** завершения работы метода. Ответственность за их выполнение лежит на **реализации** метода.
  - *Пример*: Метод гарантирует, что возвращаемое значение не будет null.
- **Инварианты (Invariants)**: Условия, которые должны быть истинны для объекта **всегда**, когда он не находится в процессе изменения (т.е. до и после вызова любого публичного метода). Ответственность лежит на **реализации** класса.
  - *Пример*: В классе, представляющем диапазон, начальное значение всегда должно быть меньше или равно конечному.

## 2. Реализация в .NET

Исторически в .NET Framework существовала библиотека **Code Contracts** (`System.Diagnostics.Contracts`), которая позволяла делать статическую проверку контрактов во время компиляции и динамическую во время выполнения.

В современном .NET Core / .NET 5+ эта библиотека не развивается. На практике контрактное программирование реализуется более простыми и прагматичными способами.

### Прагматичный подход (современный .NET)

Вместо полноценной библиотеки контрактов используются стандартные механизмы языка и фреймворка для проверки условий.

#### Проверка предусловий (Preconditions)
Это самый частый сценарий. Проверка аргументов на входе в публичные методы.

```csharp
// Старый стиль
public void Process(string data)
{
    if (data == null)
    {
        throw new ArgumentNullException(nameof(data));
    }
    // ...
}

// Новый стиль с .NET 6+
public void Process(string data)
{
    ArgumentNullException.ThrowIfNull(data);
    // ...
}
```

- Используйте `ArgumentNullException.ThrowIfNull`, `ArgumentException.ThrowIfNullOrEmpty` и подобные хелперы.
- Для более сложных проверок — обычные `if` с выбрасыванием исключений (`ArgumentException`, `ArgumentOutOfRangeException`).
- Цель: "Fail Fast". Быстро упасть с понятной ошибкой, если клиент нарушил контракт.

#### Проверка постусловий (Postconditions)
Реализуется реже, но важна для гарантий, которые дает ваш метод.

```csharp
public string? GetValue(int id)
{
    var result = _service.GetValue(id);
    
    // Постусловие: мы не хотим возвращать пустую строку, лучше null.
    if (string.IsNullOrEmpty(result))
    {
        return null;
    }
    
    // В C# 11+ можно было бы использовать !! для проверки на null
    // return result!!; 
    
    // Для отладки можно использовать Debug.Assert
    Debug.Assert(result != string.Empty, "Postcondition failed: result should not be an empty string.");
    
    return result;
}
```

- `Debug.Assert`: Проверяет условие. Если оно ложно, выбрасывает исключение. **Важно:** `Debug.Assert` работает только в `DEBUG` сборках и вырезается из `RELEASE` сборок, поэтому не влияет на производительность в продакшене.
- Можно использовать `System.Diagnostics.Trace.Assert`.

#### Проверка инвариантов (Invariants)
Инварианты должны поддерживаться самим классом.

```csharp
public class DateRange
{
    public DateTime Start { get; }
    public DateTime End { get; }

    public DateRange(DateTime start, DateTime end)
    {
        // Проверка предусловий в конструкторе для установки инварианта
        if (start > end)
        {
            throw new ArgumentException("Start date cannot be after end date.");
        }
        Start = start;
        End = end;
    }

    // Никакой публичный метод не должен нарушать инвариант start <= end
}
```
- Лучший способ поддерживать инвариант — сделать объект **неизменяемым (immutable)**.
- Проверки в конструкторе и во всех публичных методах, которые могут изменить состояние объекта (если он изменяемый).
- `Debug.Assert` также можно использовать в конце методов для проверки инвариантов.

## 3. Выводы
- **Senior-level expectation**: Понимание принципов DbC и умение прагматично применять их для создания надежного и самодокументируемого кода.
- Фокус на **проверке предусловий** (guard clauses) в публичных API.
- Использование `Debug.Assert` для проверки постусловий и инвариантов во время разработки.
- Проектирование **неизменяемых (immutable)** типов для более простого поддержания инвариантов.

# Контрактное программирование и защитное кодирование

## 1. Контрактное программирование (Design by Contract, DbC)
- **Идея**: Рассматривать компоненты ПО как стороны, заключающие "контракт". Если клиент выполняет свою часть контракта (предоставляет корректные данные), то компонент гарантирует выполнение своей части.
- **Цель**: Создание надежного, предсказуемого и документированного кода. Контракты становятся частью спецификации компонента.
- **Составляющие контракта**:
  - **Предусловия (Preconditions)**: Требования к клиенту (вызывающей стороне). Что должно быть истинно **перед** вызовом метода. `(require)`
    - *Пример*: Аргумент не должен быть `null`, число должно быть положительным.
  - **Постусловия (Postconditions)**: Гарантии, которые предоставляет метод. Что должно быть истинно **после** завершения работы метода. `(ensure)`
    - *Пример*: Возвращаемое значение не `null`, объект изменил свое состояние определенным образом.
  - **Инварианты (Invariants)**: Условия, которые должны быть истинны для объекта **в течение всего его жизненного цикла** (кроме моментов, когда выполняются его методы). Это гарантия целостности состояния объекта.
    - *Пример*: `Count` в коллекции всегда должен быть больше или равен нулю.

## 2. Защитное кодирование (Defensive Coding)
- **Идея**: Принцип "никому не доверяй". Метод должен проверять все входящие данные, даже если они приходят из другой части вашей же системы. Это противоположность контрактному программированию, которое полагается на то, что вызывающая сторона выполнит предусловия.
- **Цель**: Сделать код максимально устойчивым к ошибкам и некорректному использованию.
- **Сценарии**: Особенно важно на "границах" системы:
  - Публичные API.
  - Данные, приходящие от пользователя.
  - Данные из внешних систем (БД, другие сервисы).
- **Недостатки**: Может приводить к "раздутому" коду с большим количеством повторяющихся проверок.

## 3. Сравнение подходов

| Аспект                  | Контрактное программирование                                | Защитное кодирование                                     |
| ----------------------- | ----------------------------------------------------------- | -------------------------------------------------------- |
| **Философия**           | "Клиент выполнит свою часть, если нет - это его ошибка"     | "Клиент может ошибиться, нужно защититься от всего"      |
| **Ответственность**     | Распределена между клиентом и компонентом.                  | Полностью на компоненте.                                 |
| **Обработка ошибок**    | Провал контракта - это ошибка программиста, а не исключительная ситуация. Обычно приводит к падению в debug-сборке. | Некорректные данные - это ожидаемая ситуация, обрабатываемая через исключения (`Exception`). |
| **Где использовать**    | Внутренние компоненты системы, где разработчики контролируют обе стороны вызова. | Внешние границы системы, публичные API.                 |
| **Конечный результат**  | Более чистый, лаконичный и быстрый код.                     | Более громоздкий, но потенциально более устойчивый код.   |

## 4. Практическая реализация в C#
- **Предусловия**: Проверяются в начале метода.
  - **`if (arg == null) throw new ArgumentNullException(nameof(arg));`** - классический подход.
  - **`ArgumentNullException.ThrowIfNull(arg);`** - современный синтаксис (C# 12+).
  - **`Debug.Assert(condition, "Message")`**: Проверяет условие, но **работает только в Debug-сборках**. В Release-сборке вызов полностью удаляется компилятором. Отлично подходит для проверки инвариантов и постусловий во время разработки, не влияя на производительность production-кода.
    ```csharp
    public int Calculate(int[] data)
    {
        // Предусловие: данные не должны быть null. 
        // Это ошибка программиста, если сюда пришел null.
        Debug.Assert(data != null, "Input data cannot be null");

        // ... расчеты ...
        var result = data.Length; // Просто для примера
        
        // Постусловие: результат не может быть отрицательным
        Debug.Assert(result >= 0, "Result cannot be negative");
        return result;
    }
    ```
- **Инварианты и Постусловия**: Часто проверяются с помощью `Debug.Assert()` в конце методов или с помощью юнит-тестов.

**Вывод**: В современной разработке используется гибридный подход. **Контракты** (часто в виде `Debug.Assert`) применяются для внутренней логики, чтобы поймать ошибки на этапе разработки. **Защитное кодирование** (через `if`/`throw`) применяется на границах системы для обеспечения её надежности. 