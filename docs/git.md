# Инструменты: Git

Git — это распределенная система контроля версий. Для Senior-разработчика обязательно не просто уметь делать `commit` и `push`, но и глубоко понимать, как работать с ветками, решать конфликты и использовать Git для эффективной командной работы.

## 1. Основные команды (за пределами add/commit/push)
- **`git pull --rebase`**: Вместо создания коммита слияния (`merge commit`), эта команда сначала "перемещает" ваши локальные коммиты "поверх" изменений, загруженных с сервера. Это сохраняет историю коммитов линейной и более чистой.
- **`git fetch`**: Загружает все изменения с удаленного репозитория, но **не применяет** их к вашей локальной ветке. Позволяет посмотреть, что изменилось, прежде чем делать `merge` или `rebase`.
- **`git stash`**: Временно сохраняет ваши незакоммиченные изменения, чтобы вы могли переключиться на другую ветку. `git stash pop` возвращает эти изменения обратно.
- **`git log`**: Просмотр истории коммитов. Полезные флаги: `--oneline`, `--graph`, `--decorate`.
- **`git reset`**: Отменяет коммиты.
  - `git reset --soft HEAD~1`: Отменяет последний коммит, но оставляет изменения в индексе (staged).
  - `git reset --mixed HEAD~1`: Отменяет коммит и убирает изменения из индекса (оставляет их в рабочей директории).
  - `git reset --hard HEAD~1`: **(Опасно!)** Отменяет коммит и **удаляет** все связанные с ним изменения.
- **`git revert`**: Создает **новый** коммит, который является "обратным" к указанному коммиту. Безопасный способ отменить изменения в общей ветке, так как не переписывает историю.
- **`git cherry-pick <commit-hash>`**: "Выдергивает" конкретный коммит из другой ветки и применяет его к текущей.
- **`git blame`**: Показывает, кто и когда изменял каждую строку в файле.

## 2. Ветвление (Branching)

Ветвление — ключевая особенность Git. Оно позволяет вести параллельную разработку.

### Модель ветвления GitFlow
Это одна из популярных стратегий организации веток в проекте.

- **`main` (или `master`)**
  - **Назначение**: Хранит только стабильный, готовый к релизу код. Прямые коммиты в `main` запрещены.
  - **Источник**: Только из ветки `release` или `hotfix`.
  - **Теги**: Каждый коммит в `main` должен быть помечен тегом с номером версии (например, `v1.0.1`).

- **`develop`**
  - **Назначение**: Основная ветка разработки. Содержит все последние завершенные доработки. Это "самая свежая" версия проекта.
  - **Источник**: Из веток `feature` и `release`.

- **`feature/*` (например, `feature/add-login-page`)**
  - **Назначение**: Разработка новой функциональности.
  - **Создается из**: `develop`.
  - **Вливается в**: `develop`.
  - **Жизненный цикл**: Создается -> Разрабатывается -> Вливается в `develop` -> Удаляется.

- **`release/*` (например, `release/1.1.0`)**
  - **Назначение**: Подготовка к новому релизу. На этой стадии прекращается добавление новой функциональности и происходит только исправление багов и подготовка документации.
  - **Создается из**: `develop`.
  - **Вливается в**: `main` (после завершения) и `develop` (чтобы исправления попали в основную ветку разработки).

- **`hotfix/*` (например, `hotfix/fix-critical-bug`)**
  - **Назначение**: Срочное исправление критических ошибок в продакшене.
  - **Создается из**: `main` (из тега последней версии).
  - **Вливается в**: `main` и `develop`.

## 3. Решение конфликтов слияния (Merge Conflicts)

Конфликт возникает, когда два разработчика изменили одну и ту же часть одного и того же файла в разных ветках.

- **Процесс решения**:
  1. Git останавливает слияние и помечает конфликтующие файлы.
  2. Вы открываете файл и видите маркеры:
     - `<<<<<<< HEAD`: Начало ваших изменений.
     - `=======`: Разделитель.
     - `>>>>>>> <branch-name>`: Конец изменений из другой ветки.
  3. Вы должны вручную отредактировать файл, оставив нужный код и удалив маркеры Git.
  4. После решения всех конфликтов, вы делаете `git add <conflicted-file>` для каждого файла.
  5. Завершаете слияние командой `git commit` (или `git rebase --continue`, если был rebase).

## 4. Pull Request / Merge Request
- Это не команда Git, а функция платформ вроде GitHub, GitLab, Bitbucket.
- **Процесс**:
  1. Вы пушите свою `feature`-ветку в удаленный репозиторий.
  2. Создаете Pull Request (PR) для слияния вашей ветки, например, в `develop`.
  3. Команда проводит **Code Review**: просматривает ваши изменения, оставляет комментарии, предлагает улучшения.
  4. После одобрения (approval) и прохождения автоматических проверок (CI), ветка вливается в целевую.

# Git: Продвинутое использование

Git — это стандарт де-факто для систем контроля версий. Для Senior-разработчика недостаточно знать `add`, `commit`, `push`, `pull`. Важно понимать, как эффективно работать с историей и использовать Git для поддержки сложных рабочих процессов.

## 1. Работа с историей

- **`git rebase` (Перебазирование)**
  - **Что делает**: Перемещает или объединяет последовательность коммитов на новую базовую коммит-вершину. В отличие от `merge`, `rebase` **переписывает историю**, делая ее линейной и чистой.
  - **`git rebase -i` (интерактивный режим)**: Мощный инструмент, который позволяет:
    - `squash`: Объединить несколько коммитов в один.
    - `reword`: Переименовать сообщение коммита.
    - `edit`: Остановить `rebase` на коммите, чтобы его изменить (например, разбить на несколько).
    - `drop`: Удалить коммит.
  - **Когда использовать**: Для "причесывания" истории вашей feature-ветки **перед** тем, как влить ее в общую ветку (`main` или `develop`). **Никогда не делайте rebase на общих ветках, которые используют другие разработчики!**
  
- **`git cherry-pick`**
  - **Что делает**: Применяет один конкретный коммит из другой ветки в текущую.
  - **Когда использовать**: Когда вам нужно перенести одно конкретное изменение (например, hotfix) из одной ветки в другую, не сливая все изменения.

- **`git reflog`**
  - **Что делает**: Показывает лог всех изменений `HEAD` и других ссылок в локальном репозитории. Это "журнал безопасности" Git.
  - **Когда использовать**: Когда вы "потеряли" коммит (например, после неудачного `rebase` или `reset`). `reflog` поможет найти хэш любого коммита, который когда-либо был в вашем репозитории, и вернуться к нему.

- **`git reset`**
  - **Что делает**: Сбрасывает `HEAD` до указанного состояния.
  - **Режимы**:
    - `--soft`: Перемещает `HEAD`, но оставляет изменения в индексе (staged) и в рабочей директории.
    - `--mixed` (по умолчанию): Перемещает `HEAD` и сбрасывает индекс. Изменения остаются в рабочей директории (unstaged).
    - `--hard`: Перемещает `HEAD`, сбрасывает индекс и рабочую директорию. **Все не закомиченные изменения будут потеряны!**

## 2. Стратегии ветвления (Branching Strategies)

- **GitFlow**
  - **Идея**: Строгая модель ветвления, предназначенная для проектов с запланированными релизами.
  - **Основные ветки**:
    - `main` (или `master`): Содержит только production-ready код. Каждый коммит в `main` — это новая версия, помеченная тегом.
    - `develop`: Основная ветка разработки. Содержит последнюю версию кода со всеми новыми, но еще не выпущенными фичами.
  - **Вспомогательные ветки**:
    - `feature/*`: Создаются от `develop` для разработки новой функциональности. Вливаются обратно в `develop`.
    - `release/*`: Создаются от `develop`, когда готовится новый релиз. В этой ветке происходит только стабилизация и исправление багов. После релиза вливается и в `main`, и в `develop`.
    - `hotfix/*`: Создаются от `main` для срочного исправления критических ошибок в продакшене. Вливаются и в `main`, и в `develop`.
  - **Плюсы**: Очень структурированный и предсказуемый процесс.
  - **Минусы**: Может быть избыточно сложным для небольших проектов или проектов с непрерывной поставкой (Continuous Delivery).

- **GitHub Flow / Trunk-Based Development**
  - **Идея**: Упрощенная модель, подходящая для CI/CD.
  - **Процесс**:
    1. `main` — это всегда стабильная, готовая к деплою ветка.
    2. Для любой новой работы (фича, багфикс) создается новая ветка от `main`.
    3. После завершения работы и прохождения тестов/ревью ветка вливается обратно в `main`.
    4. После слияния с `main` происходит автоматический деплой.
  - **Плюсы**: Простота, скорость, поощряет частые небольшие релизы.
  - **Минусы**: Требует очень хорошего тестового покрытия и зрелых процессов CI/CD.

## 3. Другие полезные команды

- **`git stash`**: Временно сохраняет ваши не закомиченные изменения, чтобы вы могли переключиться на другую ветку. `git stash pop` возвращает изменения обратно.
- **`git bisect`**: Автоматический бинарный поиск по истории коммитов для нахождения того, который внес ошибку. Вы помечаете "хороший" и "плохой" коммит, а Git помогает быстро найти виновника.
- **`.gitattributes`**: Файл для определения атрибутов для путей. Например, можно указать, как Git должен обрабатывать окончания строк (`eol=lf`).
- **`.gitignore`**: Указывает файлы и папки, которые Git должен игнорировать (например, папки `bin`, `obj`, файлы настроек IDE). 