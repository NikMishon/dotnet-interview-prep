# Язык C# 12: Ключевые аспекты для Senior-разработчика

## 1. Новые возможности C# 12
- **Primary Constructors**: Упрощенный синтаксис для конструкторов классов и структур. Поля объявляются прямо в сигнатуре класса, и компилятор генерирует конструктор и приватные поля.
  ```csharp
  public class Person(string name, int age)
  {
      public string Name { get; } = name;
      public int Age { get; } = age;
  }
  ```
- **Collection Expressions**: Новый, лаконичный синтаксис `[el1, el2, ...]` для создания коллекций, который работает для массивов, `List<T>`, `Span<T>` и других.
  ```csharp
  List<int> numbers = [1, 2, 3, 4];
  int[] array = [5, 6, 7];
  // Spread-оператор (...) для объединения коллекций
  int[] combined = [..array, ..numbers, 8]; // [5, 6, 7, 1, 2, 3, 4, 8]
  ```
- **`ref readonly` параметры**: Позволяют передавать `ref`-параметры без возможности их изменения. Это способ избежать копирования больших структур при передаче в метод, гарантируя при этом, что метод не изменит исходную структуру.
- **Default Lambda Parameters**: Возможность указывать значения по умолчанию для параметров лямбда-выражений, как и в обычных методах.
  ```csharp
  var greet = (string name = "World") => $"Hello, {name}!";
  greet(); // "Hello, World!"
  greet("Misha"); // "Hello, Misha!"
  ```
- **Alias Any Type**: Возможность создавать псевдонимы (`using`) для любого типа, а не только для именованных. Особенно полезно для кортежей.
  ```csharp
  using Point = (int X, int Y);
  Point p = (10, 20);
  Console.WriteLine(p.X);
  ```

## 2. Асинхронное программирование
- **`async`/`await`**: Глубокое понимание, как это работает "под капотом". Компилятор превращает `async`-метод в машину состояний (state machine) — класс со всеми переменными метода и текущим состоянием. `await` подписывается на завершение `Task` и регистрирует продолжение (остаток метода) для выполнения, когда `Task` завершится.
- **`Task` vs `ValueTask`**: `ValueTask` — это структура, которая может оборачивать как `Task`, так и `TResult`. Используйте `ValueTask`, когда ожидается, что метод **часто будет завершаться синхронно** (например, при кэшировании данных). Это позволяет избежать аллокации `Task` в куче в синхронном случае. Если метод почти всегда асинхронный, используйте `Task`.
- **`ConfigureAwait(false)`**: Значение и важность в библиотечном коде для избежания deadlock. В GUI и ASP.NET Core (старых версий) есть контекст синхронизации. `await` по умолчанию пытается вернуться в него. Если этот поток заблокирован (например, `.Result`), происходит дедлок. `ConfigureAwait(false)` говорит, что продолжение метода можно выполнить в любом потоке из `ThreadPool`, что безопасно для библиотечного кода.
- **`IAsyncEnumerable`**: Асинхронные стримы. Позволяют "лениво" получать данные асинхронно, не загружая всю коллекцию в память сразу.
  ```csharp
  async IAsyncEnumerable<string> GetPagesAsync()
  {
      for (int i = 0; i < 10; i++)
      {
          // Имитация асинхронной загрузки
          await Task.Delay(100);
          yield return $"Page {i}";
      }
  }
  
  await foreach (var page in GetPagesAsync())
  {
      Console.WriteLine(page);
  }
  ```

## 3. LINQ (Language Integrated Query)
- **Отложенное выполнение (Deferred Execution)**: Понимание того, какие операции выполняются немедленно, а какие - при итерации. Операции `Where`, `Select`, `OrderBy` только строят запрос. Операции `ToList()`, `Count()`, `FirstOrDefault()`, `foreach` инициируют выполнение запроса.
- **`IQueryable` vs `IEnumerable`**: Разница в построении дерева выражений и выполнении запросов.
    - `IEnumerable`: Работает с объектами в памяти. `Where(x => x.Price > 10)` будет итерировать всю коллекцию в памяти и фильтровать ее.
    - `IQueryable`: Работает с провайдером данных (например, EF Core). `Where(x => x.Price > 10)` будет преобразовано в дерево выражений, которое EF Core транслирует в SQL `WHERE Price > 10`. Запрос выполнится на стороне БД.
- **Оптимизация LINQ-запросов**: Как избежать распространенных ошибок производительности (N+1 проблема). Всегда стремитесь фильтровать и агрегировать данные как можно ближе к источнику (на стороне БД с `IQueryable`), а не вытягивать все в память и обрабатывать с `IEnumerable`.

## 4. Records
- **`record` и `record struct`**: Неизменяемость (immutability), по-значению семантика сравнения. Компилятор генерирует методы `Equals`, `GetHashCode` и `ToString`.
- **With-expressions**: Недеструктивное изменение объектов. Создает **копию** рекорда с измененными свойствами.
  ```csharp
  public record User(string Name, string Role);
  var user1 = new User("Admin", "Administrator");
  var user2 = user1 with { Name = "SuperAdmin" }; // user1 не изменился
  ```
- **Позиционные и номинальные рекорды**:
  ```csharp
  // Позиционный (свойства определяются в конструкторе)
  public record Point(int X, int Y);
  
  // Номинальный (свойства определяются в теле)
  public record Car
  {
      public string Make { get; init; }
      public string Model { get; init; }
  }
  ```

## 5. Pattern Matching
- **Type Pattern**: `if (obj is string s) { ... }`.
- **Relational Patterns**: `is > 10 and < 20`.
- **Logical Patterns**: `and`, `or`, `not`.
- **List Patterns (C# 11+)**: `if (list is [1, 2, ..var rest])`.
- **Использование в `switch` выражениях**: Мощный инструмент для сложной логики.
  ```csharp
  object shape = new Circle(5);
  var area = shape switch
  {
      Circle { Radius: var r } => 3.14 * r * r,
      Rectangle { Width: var w, Height: var h } => w * h,
      _ => 0
  };
  ```

## 6. Управление памятью
- **`stack` vs `heap`**: 
    - **Стек**: Быстрая память для локальных переменных (`int`, `bool`, `struct`), параметров методов, указателей. Очищается автоматически при выходе из метода.
    - **Куча**: Более медленная память для объектов (`class`, `string`), время жизни которых не привязано к конкретному методу. Очищается сборщиком мусора (GC).
- **`struct` vs `class`**: `struct` - value type (копируется по значению), `class` - reference type (копируется ссылка). `struct` лучше использовать для маленьких, неизменяемых типов данных.
- **`Span<T>` и `Memory<T>`**: Работа с непрерывными областями памяти без аллокаций на куче. `Span<T>` позволяет получить "срез" массива, строки или другой области памяти без копирования данных.
- **`ref struct`**: Типы, которые могут жить только на стеке (не могут быть полями класса, не могут быть захвачены в лямбду). `Span<T>` является `ref struct`. Это гарантия того, что `Span` не "переживет" область памяти, на которую он указывает.

## 7. Другие важные темы
- **Атрибуты**: Создание и использование кастомных атрибутов, рефлексия. Атрибуты — это метаданные, которые можно прикрепить к коду и прочитать во время выполнения через рефлексию.
  ```csharp
  [AttributeUsage(AttributeTargets.Method)]
  public class MyTestAttribute : Attribute { }

  [MyTest]
  public void MyTestMethod() { }
  ```
- **Generics**: Обобщения, ковариантность и контрвариантность.
    - **Ковариантность (`out`)**: Позволяет использовать более производный тип, чем указан в `generic`. `IEnumerable<string>` можно присвоить `IEnumerable<object>`.
    - **Контрвариантность (`in`)**: Позволяет использовать более базовый тип. `Action<object>` можно присвоить `Action<string>`.
- **Делегаты и события**: Основа для многих паттернов (включая события в UI). `delegate` - это тип, который представляет ссылку на метод. `event` - это безопасная "обертка" над делегатом, которая позволяет только добавлять/удалять обработчики (`+=`, `-=`) извне, а вызывать - только изнутри класса.
- **Expression Trees**: Динамическое построение и компиляция кода. Представление кода в виде древовидной структуры данных. Используется в LINQ-провайдерах (EF Core) для трансляции C#-кода в SQL. 