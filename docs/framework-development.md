# Разработка библиотек и фреймворков в .NET

Создание качественной, переиспользуемой библиотеки (NuGet-пакета) требует большего, чем просто написание работающего кода. Важно думать о дизайне API, управлении зависимостями, версионировании и обратной совместимости.

## 1. Дизайн API (API Design)
- **Простота и понятность**: API должен быть интуитивно понятным. Названия классов и методов должны четко отражать их назначение.
- **Минимальная "поверхность" API (`API Surface`)**: Делайте публичным только то, что действительно необходимо для использования библиотеки. Все остальное должно быть `internal` или `private`.
- **Согласованность**: API должен быть консистентным. Используйте одинаковые паттерны и соглашения об именовании во всей библиотеке. Следуйте [гайдлайнам по именованию от Microsoft](https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines).
- **Избегайте "дырявых" абстракций**: Абстракция не должна раскрывать детали реализации, которые не важны для пользователя.
- **Использование `internal`**: `internal` классы и методы видны внутри одной сборки (проекта), но не видны для других проектов, которые на нее ссылаются. Это основной инструмент для сокрытия реализации.
  - **`InternalsVisibleTo`**: Атрибут, который позволяет предоставить доступ к `internal` членам указанной "дружественной" сборке. Чаще всего используется для того, чтобы юнит-тесты могли получить доступ к внутренней реализации.

## 2. Управление зависимостями
- **Минимизируйте зависимости**: Каждая новая зависимость — это потенциальный источник проблем (конфликты версий, уязвимости). Старайтесь использовать как можно меньше внешних NuGet-пакетов.
- **Типы зависимостей в `.csproj`**:
  - `<PackageReference>`: Обычная зависимость.
  - `<FrameworkReference>`: Ссылка на "общий фреймворк", например, `Microsoft.AspNetCore.App`. Такие зависимости не упаковываются вместе с вашим пакетом, предполагается,- что они уже есть в среде выполнения.
- **PrivateAssets**: Чтобы использовать пакет во время разработки (например, анализатор кода), но не делать его транзитивной зависимостью для конечных пользователей вашей библиотеки, используйте `PrivateAssets="all"`.
  ```xml
  <PackageReference Include="Microsoft.CodeAnalysis.Analyzers" Version="3.3.3">
    <PrivateAssets>all</PrivateAssets>
    <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
  </PackageReference>
  ```

## 3. Версионирование (Versioning)
- **Семантическое версионирование (SemVer)**: `MAJOR.MINOR.PATCH`
  - **MAJOR**: Изменяется, когда вы делаете обратно несовместимые изменения (breaking changes).
  - **MINOR**: Изменяется, когда вы добавляете новую функциональность, сохраняя обратную совместимость.
  - **PATCH**: Изменяется, когда вы делаете исправления ошибок, сохраняя обратную совместимость.
- **Обратная совместимость (Backwards Compatibility)**:
  - **Что считается Breaking Change?**
    - Удаление или переименование публичного типа, метода, свойства.
    - Изменение сигнатуры публичного метода (изменение типа, добавление/удаление параметров).
    - Добавление абстрактного члена в класс или нового члена в интерфейс (если пользователи реализуют его).
    - Изменение поведения кода, на которое могли полагаться пользователи.
  - **Как избежать Breaking Changes?**
    - Не удаляйте публичные члены. Помечайте их атрибутом `[Obsolete("...")]`.
    - Не изменяйте сигнатуры. Вместо этого добавляйте новые перегрузки методов.
    - Осторожно изменяйте `internal` код, если он виден тестам через `InternalsVisibleTo`.

## 4. Мультитаргетинг (Multi-targeting)
- **`TargetFrameworks`**: Если ваша библиотека должна поддерживать несколько версий .NET (например, .NET Standard 2.0, .NET 6, .NET 8), используйте свойство `TargetFrameworks` в `.csproj` файле.
  ```xml
  <PropertyGroup>
    <TargetFrameworks>netstandard2.0;net6.0;net8.0</TargetFrameworks>
  </PropertyGroup>
  ```
- **Условная компиляция**: Используйте директивы препроцессора (`#if NET8_0 ... #endif`) для написания кода, специфичного для определенной версии фреймворка.

## 5. Документация и упаковка
- **XML-комментарии**: Пишите подробные XML-комментарии для всех публичных членов. Они будут включены в IntelliSense в Visual Studio.
- **SourceLink**: Включите SourceLink в вашем проекте. Это позволит пользователям вашей библиотеки отлаживать ваш код, автоматически загружая исходники с GitHub.
- **`.nuspec` / `.csproj` свойства**: Заполняйте метаданные пакета (авторы, описание, иконка, ссылка на проект и т.д.) в файле `.csproj`. Это информация, которая будет отображаться на nuget.org.

## 6. Производительность и безопасность
- **`ConfigureAwait(false)`**: **Обязательно** для использования во всех `await`-ах в библиотечном коде, чтобы избежать захвата контекста синхронизации и предотвратить дедлоки в приложениях-потребителях.
- **Избегание лишних аллокаций**: Использование `struct`, `Span<T>`, `ValueTask`, пулинг объектов (`ObjectPool`) там, где это оправдано, для снижения нагрузки на GC.
- **Валидация на "границах"**: Все публичные методы должны валидировать свои аргументы (`ArgumentNullException`, `ArgumentOutOfRangeException` и т.д.). Нельзя доверять данным, приходящим извне.

## 7. Документация и тестирование
- **XML-комментарии**: Все публичные типы и члены должны быть документированы с помощью XML-комментариев. Они используются для генерации документации и отображаются в IntelliSense в Visual Studio.
- **Unit-тесты**: Покрытие публичного API тестами — обязательно. Это гарантия того, что ваш код работает как ожидается, и защита от регрессий в будущем.
- **Примеры использования**: Хорошая библиотека должна сопровождаться понятными примерами использования (в виде `README.md`, папки с примерами или полноценной документации). 