# Многопоточность и асинхронность в .NET

## 1. Базовые концепции
- **Процесс**: Изолированная область памяти, в которой выполняется приложение. Содержит как минимум один поток.
- **Поток (Thread)**: Единица выполнения внутри процесса. Потоки одного процесса разделяют общую память (кучу), но у каждого свой стек.
- **Многопоточность**: Одновременное выполнение нескольких потоков в одном процессе. Позволяет повысить отзывчивость UI и производительность на многоядерных CPU.
- **Конкурентность (Concurrency)** vs **Параллелизм (Parallelism)**:
  - **Конкурентность**: Задача разбита на части, которые могут выполняться вперемешку (не обязательно одновременно). Например, асинхронный метод на одном потоке.
  - **Параллелизм**: Задача разбита на части, которые выполняются **физически одновременно** на разных ядрах CPU.
- **ThreadPool**: Пул потоков, управляемый CLR, для выполнения коротких рабочих задач. Использование `ThreadPool` (`Task.Run`) предпочтительнее, чем создание потоков вручную (`new Thread()`), т.к. это позволяет избежать накладных расходов на создание/уничтожение потоков.

## 2. Примитивы синхронизации
Необходимы для безопасного доступа к общим данным из нескольких потоков, чтобы избежать состояния гонки (race condition).

- **`lock` (Monitor)**: Самый простой способ обеспечить эксклюзивный доступ к блоку кода. Поток, который входит в `lock`, захватывает "замок". Другие потоки, пытающиеся войти, будут заблокированы до тех пор, пока "замок" не будет освобожден.
  ```csharp
  private readonly object _lockObject = new object();
  private int _counter;

  public void Increment()
  {
      lock (_lockObject)
      {
          _counter++;
      }
  }
  ```
- **`Mutex`**: Похож на `lock`, но работает **между процессами**. Гораздо медленнее, чем `lock`, и используется для синхронизации доступа к общим ресурсам на уровне операционной системы (например, именованный файл).
- **`Semaphore` / `SemaphoreSlim`**: Ограничивает количество потоков, которые могут одновременно получить доступ к ресурсу. `SemaphoreSlim` — это более легкая и быстрая версия для использования в рамках одного процесса.
  ```csharp
  // Разрешаем не более 3 потоков одновременно
  private readonly SemaphoreSlim _semaphore = new SemaphoreSlim(3);

  public async Task DoWorkAsync()
  {
      await _semaphore.WaitAsync(); // Ждем, пока семафор освободится
      try
      {
          // ... работа с ресурсом ...
          await Task.Delay(1000);
      }
      finally
      {
          _semaphore.Release(); // Освобождаем место для другого потока
      }
  }
  ```
- **`AutoResetEvent` / `ManualResetEventSlim`**: Сигнальные механизмы. Потоки могут ждать (`WaitOne`), пока другой поток не подаст сигнал (`Set`).
  - `AutoResetEvent`: Автоматически "сбрасывается" после того, как один поток прошел. Пропускает только один поток за раз.
  - `ManualResetEventSlim`: Остается в сигнальном состоянии, пока его не сбросят вручную (`Reset`). Пропускает все ожидающие потоки.

## 3. `async`/`await` и Task Parallel Library (TPL)
- **`Task`**: Центральная концепция в TPL. Представляет асинхронную операцию, которая может завершиться в будущем и вернуть результат.
- **`Task.Run()`**: Запускает задачу в `ThreadPool`. Используется для выноса CPU-bound (вычислительных) операций из потока UI или основного потока обработки запроса, чтобы не блокировать их.
- **`async`/`await`**: Синтаксический сахар, который позволяет писать асинхронный код в синхронном стиле. `await` не блокирует поток, а освобождает его для выполнения других задач, пока ожидаемая операция не завершится.
- **`CancellationToken`**: Стандартный механизм для отмены асинхронных операций.
  ```csharp
  public async Task ProcessDataAsync(CancellationToken cancellationToken)
  {
      for (int i = 0; i < 100; i++)
      {
          // Проверяем, не запрошена ли отмена
          cancellationToken.ThrowIfCancellationRequested();

          // ... долгая работа ...
          await Task.Delay(100, cancellationToken);
      }
  }
  ```
- **`Parallel.ForEach` / `PLINQ`**: Инструменты для распараллеливания CPU-bound задач. `Parallel.ForEach` выполняет цикл параллельно, а PLINQ (`.AsParallel()`) позволяет выполнять LINQ-запросы параллельно. Следует использовать с осторожностью, т.к. накладные расходы на синхронизацию могут превысить выигрыш от параллелизма на простых операциях.

## 4. Потокобезопасные коллекции
- **Находятся в `System.Collections.Concurrent`**.
- **`ConcurrentQueue<T>`**: Потокобезопасная очередь (FIFO).
- **`ConcurrentStack<T>`**: Потокобезопасный стек (LIFO).
- **`ConcurrentBag<T>`**: Потокобезопасное неупорядоченное хранилище. Оптимизировано для сценариев, где один и тот же поток часто добавляет и удаляет элементы.
- **`ConcurrentDictionary<TKey, TValue>`**: Потокобезопасный словарь. Предоставляет атомарные операции, такие как `TryAdd`, `TryGetValue`, `AddOrUpdate`.
- **`BlockingCollection<T>`**: Обертка над `IProducerConsumerCollection` (например, `ConcurrentQueue`), которая блокирует поток-потребитель, если коллекция пуста, до тех пор, пока не появится новый элемент. Реализует паттерн "Производитель-потребитель".

## 5. Различия: Параллелизм vs Асинхронность
- **Параллелизм (Parallelism)**: Выполнение нескольких задач **одновременно** на нескольких ядрах процессора. Цель - ускорить **CPU-bound** операции.
  - Пример: `Parallel.ForEach`, `PLINQ`.
- **Асинхронность (Asynchrony)**: Выполнение задачи без блокировки вызывающего потока. Цель - освободить поток для выполнения другой работы, пока ожидается завершение **I/O-bound** операции (например, запрос к базе данных, HTTP-вызов, чтение файла).
  - Пример: `async`/`await` с методами, возвращающими `Task`.

## 6. PLINQ (Parallel LINQ)
- **`.AsParallel()`**: Позволяет выполнять LINQ-запросы параллельно на нескольких потоках.
- **Когда использовать**: Только для **CPU-bound** операций над коллекциями в памяти. Не использовать с `IQueryable` (например, с EF Core), так как это приведет к загрузке всех данных в память и только потом к параллельной обработке.

## 7. Распространенные проблемы
- **Deadlock (взаимная блокировка)**: Два потока бесконечно ожидают друг друга, так как каждый заблокировал ресурс, необходимый другому.
- **Race Condition (состояние гонки)**: Результат операции зависит от непредсказуемого порядка выполнения потоков.
- **Resource Starvation (нехватка ресурсов)**: Поток не может получить доступ к ресурсу в течение длительного времени. 