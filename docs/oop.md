# Объектно-ориентированное программирование (ООП)

ООП — это парадигма программирования, основанная на представлении программы в виде совокупности взаимодействующих объектов, каждый из которых является экземпляром определенного класса.

## Основные принципы ООП

### 1. Инкапсуляция (Encapsulation)
- **Определение**: Сокрытие внутреннего состояния и реализации объекта и предоставление наружу только публичного интерфейса (набора методов). Объект сам управляет своим состоянием и защищает его от некорректного внешнего вмешательства.
- **Цель**: Уменьшение сложности системы и повышение ее надежности. Позволяет изменять внутреннюю реализацию объекта, не затрагивая код, который его использует.
- **Пример в C#**:
  ```csharp
  public class BankAccount
  {
      // Состояние (баланс) скрыто (private)
      private decimal _balance;

      // Публичный метод для внесения денег
      public void Deposit(decimal amount)
      {
          if (amount > 0)
          {
              _balance += amount;
          }
      }

      // Публичное свойство для получения баланса (только чтение)
      public decimal Balance => _balance;
  }
  ```

### 2. Наследование (Inheritance)
- **Определение**: Механизм, который позволяет создавать новый класс (потомок, `derived class`) на основе существующего (родитель, `base class`). Потомок "наследует" публичные и защищенные (`protected`) члены родителя.
- **Цель**: Переиспользование кода и построение иерархии классов.
- **Пример в C#**:
  ```csharp
  // Базовый класс
  public class Animal
  {
      public string Name { get; set; }

      public void Eat()
      {
          Console.WriteLine($"{Name} ест.");
      }
  }

  // Класс-потомок
  public class Dog : Animal
  {
      public void Bark()
      {
          Console.WriteLine("Гав!");
      }
  }
  
  var dog = new Dog { Name = "Шарик" };
  dog.Eat(); // Унаследованный метод
  dog.Bark(); // Собственный метод
  ```

### 3. Полиморфизм (Polymorphism)
- **Определение**: "Один интерфейс, множество реализаций". Способность объекта использовать методы производного класса, который не существует на момент создания базового. Объекты разных классов могут реагировать на один и тот же вызов метода по-разному.
- **Цель**: Гибкость и расширяемость системы. Позволяет писать код, который работает с объектами на уровне их базового типа, не зная о конкретной реализации.
- **Реализуется через**: `virtual` и `override` методы, `abstract` методы, интерфейсы.
- **Пример в C#**:
  ```csharp
  public abstract class Shape
  {
      // Абстрактный метод, который должны реализовать все потомки
      public abstract double CalculateArea();
  }

  public class Circle : Shape
  {
      public double Radius { get; set; }
      public override double CalculateArea() => Math.PI * Radius * Radius;
  }

  public class Rectangle : Shape
  {
      public double Width { get; set; }
      public double Height { get; set; }
      public override double CalculateArea() => Width * Height;
  }

  // Метод работает с любым Shape, не зная, круг это или прямоугольник
  void PrintArea(Shape shape)
  {
      Console.WriteLine($"Площадь: {shape.CalculateArea()}");
  }
  ```

### 4. Абстракция (Abstraction)
- **Определение**: Выделение наиболее значимых характеристик объекта и игнорирование несущественных. Абстракция определяет "что" объект делает, а не "как" он это делает.
- **Цель**: Снижение сложности путем моделирования классов, соответствующих реальным объектам или концепциям, и предоставления простого интерфейса для работы с ними.
- **Реализуется через**: `abstract` классы и `interface`.
- **Пример в C#**:
  - `abstract class`: Может содержать как реализацию по умолчанию, так и абстрактные члены, которые должны быть реализованы в потомках. Нельзя создать экземпляр абстрактного класса.
  - `interface`: Определяет только "контракт" - набор публичных методов и свойств, без их реализации. Класс может реализовывать несколько интерфейсов.
  ```csharp
  // Интерфейс определяет, что "умеет" делать объект
  public interface ILogger
  {
      void LogMessage(string message);
      void LogError(string error);
  }

  // Класс реализует этот контракт
  public class FileLogger : ILogger
  {
      public void LogMessage(string message) { /* ... запись в файл ... */ }
      public void LogError(string error) { /* ... запись в файл ... */ }
  }
  ```
