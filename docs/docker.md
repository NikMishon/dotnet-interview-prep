# Docker: Основы для .NET-разработчика

Docker — это платформа для контейнеризации, которая позволяет "упаковать" приложение и его зависимости в изолированный контейнер. Этот контейнер можно запускать где угодно, обеспечивая идентичность окружения от разработки до продакшена.

## 1. Ключевые концепции
- **Image (Образ)**: Шаблон для создания контейнеров, доступный только для чтения. Образ состоит из слоев. Каждый слой представляет собой инструкцию в `Dockerfile`. Образы хранятся в реестре (например, Docker Hub).
- **Container (Контейнер)**: Запущенный экземпляр образа. Контейнер изолирован от хост-системы и других контейнеров.
- **Dockerfile**: Текстовый файл с инструкциями для сборки образа Docker.
- **Registry (Реестр)**: Хранилище для образов. Docker Hub — это публичный реестр по умолчанию.
- **Volume (Том)**: Механизм для сохранения данных, генерируемых и используемых контейнерами. Данные в томе сохраняются даже после удаления контейнера.

## 2. Dockerfile для ASP.NET Core приложения

Для .NET-приложений принято использовать **многоступенчатую сборку (multi-stage build)**. Это позволяет создать итоговый образ минимального размера, который не содержит SDK, исходного кода и промежуточных файлов.

```dockerfile
# --- Этап 1: Сборка приложения ---
# Используем образ с полным .NET SDK для сборки
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /src

# Копируем файлы проекта и восстанавливаем зависимости
# Копируем .csproj и .sln отдельно, чтобы кэшировать слой с зависимостями
COPY ["MyApp.csproj", "."]
RUN dotnet restore "./MyApp.csproj"

# Копируем остальной исходный код
COPY . .
WORKDIR "/src/."
# Собираем приложение в Release-конфигурации
RUN dotnet build "MyApp.csproj" -c Release -o /app/build

# --- Этап 2: Публикация приложения ---
FROM build AS publish
# Публикуем приложение, создавая готовые к запуску артефакты
RUN dotnet publish "MyApp.csproj" -c Release -o /app/publish

# --- Этап 3: Создание финального, легковесного образа ---
# Используем образ только со средой выполнения ASP.NET Core (без SDK)
FROM mcr.microsoft.com/dotnet/aspnet:8.0 AS final
WORKDIR /app
# Копируем только опубликованные артефакты из этапа "publish"
COPY --from=publish /app/publish .
# Указываем команду для запуска приложения
ENTRYPOINT ["dotnet", "MyApp.dll"]
```

### Основные инструкции Dockerfile:
- `FROM`: Указывает базовый образ.
- `WORKDIR`: Устанавливает рабочую директорию внутри контейнера.
- `COPY`: Копирует файлы и папки из хост-системы в контейнер.
- `RUN`: Выполняет команду внутри контейнера на этапе сборки.
- `ENTRYPOINT`: Указывает команду, которая будет выполняться при запуске контейнера.

## 3. docker-compose
- **Что это**: Инструмент для определения и запуска многоконтейнерных Docker-приложений.
- **`docker-compose.yml`**: Файл в формате YAML, в котором описываются все сервисы, сети и тома для вашего приложения.
- **Зачем нужно**: Позволяет одной командой (`docker-compose up`) поднять всю необходимую для работы инфраструктуру: ваше приложение, базу данных (PostgreSQL, MS SQL), кэш (Redis), брокер сообщений (RabbitMQ) и т.д.
- **Пример `docker-compose.yml`**:
  ```yaml
  version: '3.8'

  services:
    # Сервис нашего веб-приложения
    webapp:
      build: 
        context: . # Указывает, где находится Dockerfile
        dockerfile: MyApp/Dockerfile
      ports:
        - "8080:80" # Пробрасывает порт 8080 хоста на порт 80 контейнера
      environment:
        - ConnectionStrings__Database=Host=db;Database=myapp;Username=user;Password=pass
      depends_on:
        - db # Указывает, что этот сервис зависит от сервиса "db"

    # Сервис базы данных PostgreSQL
    db:
      image: "postgres:15" # Используем готовый образ из Docker Hub
      environment:
        - POSTGRES_USER=user
        - POSTGRES_PASSWORD=pass
        - POSTGRES_DB=myapp
      volumes:
        - postgres_data:/var/lib/postgresql/data # Сохраняем данные в volume

  volumes:
    postgres_data: # Объявляем именованный том
  ```

## 4. Основные команды CLI
- `docker build -t my-app-name .`: Собрать образ из `Dockerfile` в текущей директории и присвоить ему имя `my-app-name`.
- `docker run -p 8080:80 my-app-name`: Запустить контейнер из образа `my-app-name` и пробросить порт `80` контейнера на порт `8080` хоста.
- `docker ps`: Показать все запущенные контейнеры.
- `docker images`: Показать все скачанные образы.
- `docker-compose up`: Собрать (если нужно) и запустить все сервисы, описанные в `docker-compose.yml`.
- `docker-compose down`: Остановить и удалить контейнеры, сети, созданные `docker-compose up`. 